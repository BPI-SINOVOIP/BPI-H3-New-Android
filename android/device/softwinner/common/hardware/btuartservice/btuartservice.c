#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <stddef.h>
#include <ctype.h>
#include <stdarg.h>
#include <cutils/klog.h>
#include <cutils/properties.h>

#include <private/android_filesystem_config.h>


#define ERROR(x...)   KLOG_ERROR("btusrtservice", x)
#define NOTICE(x...)  KLOG_NOTICE("btusrtservice", x)
#define INFO(x...)    KLOG_INFO("btusrtservice", x)

static unsigned int android_name_to_id(const char *name)
{
    const struct android_id_info *info = android_ids;
    unsigned int n;

    for (n = 0; n < android_id_count; n++) {
        if (!strcmp(info[n].name, name))
            return info[n].aid;
    }

    return -1U;
}

static unsigned int decode_uid(const char *s)
{
    unsigned int v;

    if (!s || *s == '\0')
        return -1U;
    if (isalpha(s[0]))
        return android_name_to_id(s);

    errno = 0;
    v = (unsigned int) strtoul(s, 0, 0);
    if (errno)
        return -1U;
    return v;
}

static int _open(const char *path)
{
    int fd;

    fd = open(path, O_RDONLY | O_NOFOLLOW);
    if (fd < 0)
        fd = open(path, O_WRONLY | O_NOFOLLOW);

    return fd;
}

static int _chown(const char *path, unsigned int uid, unsigned int gid)
{
    int fd;
    int ret;

    fd = _open(path);
    if (fd < 0) {
        return -1;
    }

    ret = fchown(fd, uid, gid);
    if (ret < 0) {
        int errno_copy = errno;
        close(fd);
        errno = errno_copy;
        return -1;
    }

    close(fd);

    return 0;
}

static int _chmod(const char *path, mode_t mode)
{
    int fd;
    int ret;

    fd = _open(path);
    if (fd < 0) {
        return -1;
    }

    ret = fchmod(fd, mode);
    if (ret < 0) {
        int errno_copy = errno;
        close(fd);
        errno = errno_copy;
        return -1;
    }

    close(fd);

    return 0;
}


static int do_chown(int nargs, char **args) {
    /* GID is optional. */
    if (nargs == 3) {
        if (_chown(args[2], decode_uid(args[1]), -1) < 0)
            return -errno;
    } else if (nargs == 4) {
        if (_chown(args[3], decode_uid(args[1]), decode_uid(args[2])) < 0)
            return -errno;
    } else {
        return -1;
    }
    return 0;
}

static mode_t get_mode(const char *s) {
    mode_t mode = 0;
    while (*s) {
        if (*s >= '0' && *s <= '7') {
            mode = (mode<<3) | (*s-'0');
        } else {
            return -1;
        }
        s++;
    }
    return mode;
}

static int do_chmod(int nargs, char **args) {
    mode_t mode = get_mode(args[1]);
    if (_chmod(args[2], mode) < 0) {
        return -errno;
    }
    return 0;
}

#define BT_UART_PROPERTY  "persist.service.bdroid.uart"

static char *chmod_arg[3] = {"chmod", "660"};
static char *chown_arg[4] = {"chown", "bluetooth", "net_bt_stack"};

int main(int argc, char **argv)
{
	char pval[256];

	if (property_get(BT_UART_PROPERTY, pval, NULL) > 0)
	{
		INFO("%s = %s\n", BT_UART_PROPERTY, pval);
		chmod_arg[2] = pval;
		chown_arg[3] = pval;

		if (do_chmod(3, chmod_arg))
			ERROR("chmod error...\n");
		if (do_chown(4, chown_arg))
			ERROR("chown error...\n");
	}
	else
		ERROR("get property: %s failed...\n", BT_UART_PROPERTY);

	return 0;
}
